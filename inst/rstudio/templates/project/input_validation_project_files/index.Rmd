--- 
title: "Immcantation - enchantR"
author: ""
date: "Updated: `r date()`"
site: bookdown::bookdown_site
documentclass: book
bibliography: "references.bib"
biblio-style: apalike
link-citations: yes
description: "enchantr input validation report"
output:
   bookdown::gitbook:
      config:
         fig_caption: yes
         toc:
            scroll_highlight: yes
            collapse: subsection
            depth: 4
            before: |
               <!-- <li><a href="javascript:window.location.href='./'">Report contents</a></li> -->
            after: |
               </a></li>
               <li><a href="http://immcantation.readthedocs.io" target="blank"><img src='logo.png'></a></li>
         download: no
         sharing: no
         keep_md: false
      fontsettings:
         theme: white
         family: sans
         size: 1
      highlight: pygments
      css: style.css
         # self_contained: true
         # split_by: none
params:
   input: 
      label: "`input`: Path to input metadata file"
      input: file
      value: "example_airr_metadata.tsv"
   collapseby: 
      label: "`collapseby`: Fields in `input` that group data to collapse duplicated sequences"
      value: 'sample_id'
   cloneby:
      label: "`cloneby`: Fields in `input` that group data to identify groups of clonally related sequences"
      value: 'subject_id'
   reassign: 
      label: '`reassign`: if `input` is a .tsv repertoire, will gene calls be reassigned later in the pipeline?'
      input: checkbox
      value: FALSE   
   output: 'validated_input'
   miairr: 
      label: "`miairr`: Path to AIRR standard mapping file."
      input: file
      value: "mapping_MiAIRR_BioSample_v1.3.1.tsv"
   outdir:
      label: '`outdir`: Output directory'
      input: text
      value: !r file.path(getwd(),'enchantr')
   date: 
      label: '`date`: Run date'
      input: date
      value: !r format(Sys.time(), "%Y-%m-%d")
   logo:
      label: "`logo`: Path to report logo"
      input: file
      value: "logo.png"
   logolink:
      label: "`logolink`: URL to be added to the logo"
      input: text
      value: "immcantation.org"
   echo: 
      label: '`echo`: Show code in the report.'
      input: checkbox
      value: FALSE
   cache:
      label: '`cache`: Use cached results'
      input: checkbox
      value: FALSE
editor_options: 
  chunk_output_type: inline
---

```{r global-options, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(fig.width=7, fig.height=4, fig.path = "figures/",
                      echo=params$echo,cache=params$cache,
                      warning=FALSE, message=FALSE,
                      out_dir=params$outdir,
                      eval.opts = c('eval', 'echo', 'fig.height', 'fig.width'))
library(enchantr)
library(dplyr)
library(airr)
library(DT)
library(plotly)
file.copy(params$logo, file.path(params$outdir,paste0("logo", gsub(".+(\\..+$)","\\1",params$logo))))
```

# Input parameters

```{r input-parameters}
params
dir.create(params$outdir, recursive = T)
save(params, file=file.path(params$outdir,"params.RData"))
```

# Metadata validation


```{r}
# Settings
# Valid species. Use lower case.
valid_species <- list("human"=c("human", "homo sapiens", "h. sapiens", "hs"),
                        "mouse"=c("mouse", "mus musculus", "mm"))
# Check miairr file
if (!("miairr" %in% names(params))) {
   stop("You must provide a miairr standard file with --miairr.")
}

# Check input file
if (!("miairr" %in% names(params))) {
    stop("You must provide an input file with --input.")
}

# Read metadata file
input <- read.csv(params$input,sep = "\t", header=TRUE, stringsAsFactors = F)

# Validate metadata file
miairr_metadata <- read.csv(params$miairr, sep="\t", stringsAsFactors = F)
mandatory <- miairr_metadata[['Mandatory.BioSample.attribute']] == TRUE
mandatory_fields <- setdiff(c(miairr_metadata[['AIRR.Formats.WG.field.name']][mandatory], "pcr_target_locus", "single_cell", "species"), "organism")

if (!all(mandatory_fields %in% colnames(input))) {
   missing_fields <- mandatory_fields[mandatory_fields %in% colnames(input) == FALSE]
   if ((missing_fields == "species") & ("organism" %in% colnames(input))) {
         message("Missing 'species' field, using 'organism' field instead.")
         input[['species']] <- input[['organism']]
   } else {
      stop("Missing MiAIRR fields: ", paste(missing_fields,collapse=", "))
   }
}

# Add filetype
input$filetype <- sub(".+\\.([^\\.]+)$","\\1", input$filename)

# Validate `filename`
# `filename` must be unique and must contain .fasta, fa or .tsv files
input$valid_filename <- sapply(basename(input[,'filename']), function(fn) {
   fn <- strsplit(fn, "\\.")[[1]]
   fn[length(fn)] %in% c("fasta", "fa", "tsv")
})

dup_filenames <- input[,'filename'][duplicated(input[,'filename'])]
if (length(dup_filenames)>0) {
   input$valid_filename[input[,'filename'] %in% dup_filenames] <- FALSE
}

#TODO validate MiAIRR fields

# `species` must exist, then translate to name format
# suitable for igblast and downstream analysis
get_valid_species <- function(dictionary, words) {
   dictionary <-  bind_rows(lapply(dictionary, function(x) {data.frame("species"=x)} ), .id="valid_species")
   sapply(words, function(word){
      if (is.na(word)) {
         warning("No `species` mapping available for: `",word,"`.")
         return (NA)
      }
      valid_species <- dictionary %>%
         filter(species == tolower(word)) %>%
         distinct(valid_species)
      if (nrow(valid_species)>0){
         if(length(col)>1) {
            warning("Multiple `species` mappings found for ",word,": ", paste(as.character(valid_species), collapse=","))
            NA
         } else {
            as.character(valid_species)
         }
      } else {
         warning("No `species` mapping available for: `",word,"`.")
         NA
      }
   })
}

species <- get_valid_species(valid_species, input[['species']])
input[,'species'] <- species
not_valid_species <- species[is.na(species)]

input[,'valid_species'] <- TRUE
if (length(not_valid_species)>0) {
   input[is.na(species),'valid_species'] <- FALSE
}


## TODO: make a function to do column name validations
# Validate collapseby
collapseby <- strsplit(params$collapseby,",")[[1]]

# cell_id is a rearrangement property, don't check here
# will be validated when rearrangements are loaded
collapseby <- setdiff(collapseby, "cell_id")

unknown_collapseby <- collapseby[collapseby %in% colnames(input) == FALSE]
if (length(unknown_collapseby)>0) {
   stop("Unknown `collapseby` found: ", paste(unknown_collapseby, collapse = ","))
} else {
   input$valid_collapseby <- T
}

input$collapseby_group <- apply(input,1, function(x) {
   paste(x[collapseby],collapse = ",")
})

input <- input %>%
   group_by(collapseby_group) %>%
   mutate(collapseby_size=n()) %>%
   ungroup()

# Validate cloneby
cloneby <- strsplit(params$cloneby,",")[[1]]
unknown_cloneby <- cloneby[cloneby %in% colnames(input) == FALSE]
if (length(unknown_cloneby)>0) {
   stop("Unknown `cloneby` found: ", paste(unknown_cloneby, collapse = ","))
} else {
   input$valid_cloneby <- T
}

input$cloneby_group <- apply(input,1, function(x) {
   paste(x[cloneby],collapse = ",")
})

input <- input %>%
   group_by(cloneby_group) %>%
   mutate(cloneby_size=n()) %>%
   ungroup()

input$id <- paste0("input_id_", 1:nrow(input))

# Validate single_Cell field. Should be true or false
input$valid_single_cell <- input[['single_cell']] %in% c(T,F,"true", "false", "TRUE","FALSE")
is_single_cell <- input[['single_cell']] %in% c(T,"true", "TRUE")
if (sum(is_single_cell)>0) {
   input[['single_cell']][is_single_cell] <- "true"
}
if (sum(!is_single_cell)>0) {
   input[['single_cell']][!is_single_cell] <- "false"
}

# Validate pcr_target_locus
input[['valid_pcr_target_locus']]  <- tolower(input[['pcr_target_locus']]) %in% tolower(c("IGH", "IGI", "IGK", "IGL", "TRA", "TRB", "TRD", "TRG", "IG", "TR"))
input[['locus']] <- tolower(substr(input[['pcr_target_locus']],1,2))


# If reassign is false, check that tsv files have 
# all fields required by Immcantation (TODO)
# and sequence_alignment has IMGT gaps
if (!params$reassign) {
   input$valid_sequence_alignment <- apply(input, 1, function(x) {
      if (x[['filetype']] == "tsv") {
         # if tsv files, look for presence of imgt gaps (.) in the
         # first rows
         any(grepl("\\.",read_rearrangement(x[['filename']], n_max=200)[['sequence_alignment']]))
      } else {
         # for non tsv files
         TRUE
      }
   })
} else {
   # If reassign, sequence_alignment will be created later
   # in the pipeline, and will have imgt gaps 
   input$valid_sequence_alignment <- TRUE
}
```

```{r}
# Write validation results to a file
write.table(input, file=file.path(params$outdir, paste0(params$output,".tsv")), sep="\t",
            quote=FALSE, row.names = FALSE)

# DT::saveWidget(dt, file=paste0(params$output,".html"))
```

```{r}
check_fields <- c("valid_filename", "valid_species", "valid_collapseby", "valid_cloneby", "valid_single_cell", "valid_pcr_target_locus", "valid_sequence_alignment")
not_valid_rows <- which(rowSums(input[, check_fields, drop=FALSE]) < length(check_fields))
```

```{r, error=T}
if (length(not_valid_rows) > 0) {
   write.table(input[not_valid_rows,], file=file.path(params$outdir, paste0(params$output,"_not-valid.tsv")), sep="\t",
               quote=FALSE, row.names = FALSE)
   stop("Please review your input data. Invalid information found.")
}
```

`r length(not_valid_rows)` invalid rows (row numbers: `r paste(not_valid_rows, collapse=",")`).

```{r}
dt <- DT::datatable(input,
              rownames = FALSE,
              options = list(scrollX = TRUE)
              ) %>%
   formatStyle(
      'valid_filename',
      target = 'row',
      backgroundColor = styleEqual(c(0, 1), c('lightsalmon', 'white'))
   )
dt
```

```{r, child=c('references.Rmd', 'versions.Rmd')}
```


