--- 
title: "Immcantation - enchantR"
subtitle: "Define Clones"
author: ""
date: "Updated: `r date()`"
knit: "bookdown::render_book"
site: bookdown::bookdown_site
documentclass: book
bibliography: "references.bib"
biblio-style: apalike
link-citations: yes
description: "enchantr define clones"
output: enchantr::immcantation
params:
   input: 
      label: "`input`: Path to repertoires file"
      input: file
      value: "input.tsv"
   imgt_db:
      label: "`imgt_db`: Path to IMGT reference  database."
      input: file
      value: !r NULL
   cloneby:
      label: "`cloneby`"
      input: text
      value: "sample_id"    
   singlecell:
      label: "`singlecell`"
      input: text
      value: "single_cell"          
   threshold:
      label: "`threshold`"
      input: numeric
      value: 1
   outputby:
      label: "`outputby` name of the column in `input` that contains sample identifiers that will be used to split the output db."      
      input: text
      value: "id"
   model:
      label: "`model`"
      input: text
      value: "hierarchical" 
   method:
       label: "`method`"
       input: text
       value: "nt"
   linkage:
       label: "`linkage`"
       input: text
       value: "single"
   outname:
      label: "`outname`"
      input: text
      value: "define-clones"
   nproc:
      label: "`nproc`"
      input: numeric
      value: 1      
   log:
      label: "`log`"
      input: text
      value: "command_log"
   outdir:
      label: '`outdir`: Output directory'
      input: text
      value: !r file.path(getwd(),'enchantr')
   date: 
      label: '`date`: Run date'
      input: date
      value: !r format(Sys.time(), "%Y-%m-%d")
   logo:
      label: "`logo`: Path to report logo"
      input: file
      value: !r file.path("assets", "logo.png")
   logolink:
      label: "`logolink`: URL to be added to the logo"
      input: text
      value: "immcantation.org"
   echo: 
      label: '`echo`: Show code in the report.'
      input: checkbox
      value: FALSE
   cache:
      label: '`cache`: Use cached results'
      input: checkbox
      value: FALSE
editor_options: 
  chunk_output_type: console
---


```{r global-options, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(fig.width=7, fig.height=4, fig.path = "figures/",
                      echo=params$echo,cache=params$cache,
                      warning=FALSE, message=FALSE,
                      eval.after="fig.cap",
                      out_dir=params$outdir,
                      eval.opts = c('eval', 'echo', 'fig.height', 'fig.width'))

# Libraries
suppressPackageStartupMessages(library("enchantr"))
suppressPackageStartupMessages(library("DT"))
suppressPackageStartupMessages(library("dplyr"))
suppressPackageStartupMessages(library("airr"))
suppressPackageStartupMessages(library("alakazam"))
suppressPackageStartupMessages(library("shazam"))
suppressPackageStartupMessages(library("scoper"))
suppressPackageStartupMessages(library("dowser"))

file.copy(params$logo, 
          file.path(params$outdir,"assets", paste0("logo", gsub(".+(\\..+$)","\\1",params$logo))),
          recursive = T, overwrite=T)
```

# Input parameters

```{r input-parameters}
if (!dir.exists(params[['outdir']])) {
   dir.create(params[['outdir']], recursive = T)
}
printParams(params)
save(params, file=file.path(params$outdir,"params.RData"))
```

# Read repertoires


```{r}
# Read repertoire
db <- bind_rows(lapply(strsplit(params[['input']],",")[[1]], function(x) {
    # Check input file
    if (!file.exists(x)) {
        stop(paste0("File ", basename(x), " doesn't exist."))
    }
    read_rearrangement(x)}
))
input_size <- nrow(db)
```

# Define Clones

```{r}
heavy_chains <- grepl("[hHBbDc]", db[['locus']]) #IGH, TRB, TRD
```
```{r}
if (sum(heavy_chains)>0) {
    if (params$model == "hierarchical") {
        if (all(db[[ params$singlecell ]] == T )) {
            cell_id <- 'cell_id'
        } else {
            cell_id <- NULL
            if (all(c(T,F) %in% db[[ params$singlecell ]])) {
                warning("Mix of single and bulk data. Setting cell_id=`NULL`.")
            }
        }
        db <- hierarchicalClones(db, 
                                 params$threshold, 
                                 method=params$method,
                                 linkage=params$linkage, 
                                 normalize="len",
                                 junction="junction", 
                                 v_call="v_call", j_call="j_call", 
                                 clone="clone_id", 
                                 fields=params$cloneby,
                                 cell_id=cell_id, 
                                 locus="locus", 
                                 only_heavy=TRUE, 
                                 split_light=TRUE,
                                 first=FALSE, 
                                 cdr3=FALSE, mod3=FALSE, 
                                 max_n=0, nproc=params$nproc,
                                 verbose=FALSE, log=NULL,
                                 summarize_clones=FALSE) 
    } else {
        stop("Unsuported model requested. Supported models: hierarchical")
    }
} else {
    warning("No heavy chain sequences found. Assign each sequence a clone_id.")
    db$clone_id <- as.character(1:nrow(db))
}
```

# Create germlines

```{r}
if ( length(unique(db[['species']])) > 1 ) {
    message("Message: multiple species found.")
} 
db[['tmp_nrow']] <- 1:nrow(db)
db <- bind_rows(lapply(split(db,db[['species']]),
                 function(db_sp) { 
                     species <- db_sp[['species']][1]
                     references <- readIMGT(file.path(params[['imgt_db']], species, "vdj"))
                     bind_rows(lapply(split(db_sp, db_sp[['locus']]), 
                                            function(db_locus) {
                                                locus <- db_locus[['locus']][1]
                                                db_locus <- createGermlines(
                                                    db_locus,
                                                    references,
                                                    organism = species,
                                                    locus = locus,
                                                    nproc = params$nproc,
                                                    seq = "sequence_alignment",
                                                    v_call = "v_call",
                                                    d_call = "d_call",
                                                    j_call = "j_call",
                                                    amino_acid = FALSE,
                                                    id = "sequence_id",
                                                    clone = "clone_id",
                                                    v_germ_start = "v_germline_start",
                                                    v_germ_end = "v_germline_end",
                                                    v_germ_length = "v_germline_length",
                                                    d_germ_start = "d_germline_start",
                                                    d_germ_end = "d_germline_end",
                                                    d_germ_length = "d_germline_length",
                                                    j_germ_start = "j_germline_start",
                                                    j_germ_end = "j_germline_end",
                                                    j_germ_length = "j_germline_length",
                                                    np1_length = "np1_length",
                                                    np2_length = "np2_length",
                                                    na.rm = TRUE,
                                                    fields = params$cloneby,
                                                )
                                            }))
                 })) %>%
    arrange(tmp_nrow) %>%
    select(-tmp_nrow) 
```

# Tissues per clone

```{r}
db %>%
    group_by(clone_id) %>%
    summarize(num_tissues=length(unique(tissue))) %>%
    filter(num_tissues>1)
```


# Clone size

Most real datasets, will have most clones of size 1 (one sequence).

```{r clone-size, fig.width=8, fig.height=0.7*length(unique(db[['sample_id']]))}
clone_sizes <- countClones(db[grepl("[hHBbDc]", db[['locus']]),], groups = "sample_id")

ggplot(clone_sizes, aes(x=seq_count, color=sample_id, fill=sample_id))+
    geom_bar() + theme_bw() +
    facet_wrap(~sample_id, scales = "free_y", ncol=3) +
    xlab("Clone size (Sequences per clone)")
```

## Clone size > 1

```{r clone-size-atleast2, fig.width=8}
ggplot(clone_sizes %>% filter(seq_count>1), aes(x=seq_count, color=sample_id, fill=sample_id))+
    geom_bar() + theme_bw() +
    facet_wrap(~sample_id, scales = "free_y", ncol=3) +
    xlab("Clone size (Sequences per clone)")
```


# Clonal abundance

Clonal abundance is the size of each clone (as a fraction of the entire repertoire). `estimateAbundance` estimates the clonal abundance distribution along with 
confidence intervals on these clone sizes using bootstrapping. The y-axis shows the clone abundance (i.e., the size as a percent of the repertoire) and the x-axis is a rank of each clone, where the rank is sorted by size from larger (rank 1, left) to smaller (right). The shaded areas are confidence intervals.

```{r abundancebysample}
# calculate the rank-abundance curve
a <- estimateAbundance(db, group = "sample_id", min_n = 15) # Default min_n=30
p <- plotAbundanceCurve(a, annotate="depth", silent = T) + 
           facet_wrap(~sample_id)
p
```

# Diversity

The clonal abundance distribution can be characterized using diversity statistics. Diversity scores (D) are calculated using the generalized diversity index (Hill numbers), which covers many different measures of diversity in a single function with a single varying parameter, the diversity order q.

The function alphaDiversity resamples the sequences and calculates diversity scores (D) over a interval of diversity orders (q). The diversity (D) is shown on the y-axis and the x-axis is the parameter q. - q = 0 corresponds to Species Richness - q = 1 corresponds to Shannon Entropy - q = 2 corresponds to Simpson Index

Inspection of this figure is useful to determine whether any difference in diversity between two repertoires depends on the statistic used or if it is a universal property. 

```{r diversity}
# generate the Hill diversity curve
d <- alphaDiversity(db, group = "sample_id")
p <- plotDiversityCurve(d, silent = T)
p + geom_vline(xintercept = c(0,1,2), color = "grey50", linetype = "dashed") +
    geom_text(data = data.frame(q = c(0,1,2), y = round(max(p$data$d_upper)/2),
              label = c("Richness", "Shannon", "Simpson")),
              aes(x = q, y = y,label = label), size = 3, angle = 90, vjust = -0.4, inherit.aes  =  F, color = "grey50") +
    facet_wrap(~sample_id)

```

# `junction` and `clone_id` overlap

```{r overlap}
overlap <- plotDbOverlap(db, 
                         group="sample_id", 
                         features=c("clone_id","junction"), 
                         heatmap_colors=c("white","orange", "grey80"), 
                         print_zero=FALSE, long_x_angle=90,
                         title=NULL,xlab=NULL, ylab=NULL,
                         plot_order=c("tissue","sample_id"), 
                         silent=T, similarity=c("min","jaccard"),
                         na.rm=FALSE, exact=c(TRUE, FALSE), 
                         geom_text_size=3)
```

```{r overlapplot, fig.width=8, fig.width=0.7*length(unique(db[['sample_id']])), fig.height=0.7*length(unique(db[['sample_id']]))}
overlap$p
```


# Save

```{r dbpass}
# pass <- db[['collapse_pass']]

if (!is.null(params$outname)) {
    output_fn <- paste0(params$outname,"_clone-pass.tsv")
} else {
    output_fn <- sub(".tsv$", "_clone-pass.tsv", basename(params$input))
}

if (!is.null(params$log)) {
    log_fn <- paste0(params$log,".txt")
} else {
    log_fn <- sub("_clone-pass.tsv$", "_command_log.txt", basename(output_fn))
}


# db <- data.frame(
#     'id'=c(1,2),
#     'subject_id'=c("A","A")
# )

output_files <- c()
output_sizes <- c()
if (sum(heavy_chains)>0 & nrow(db)>0) {
    
    output_groups <- db %>%
        ungroup() %>%
        select(!!!rlang::syms(params$outputby)) %>%
        distinct() 
    
    if (nrow(output_groups)>0) {
        for (i in 1:nrow(output_groups))  {
            group_db <- right_join(db,
                                   output_groups[i,,drop=F],
                                   by=params$outputby)
            
            group_db_label <- gsub("^id_","",makeLabel(group_db, fields= params$outputby))
            group_fn <- paste0(group_db_label,"_",output_fn)
            output_files <- c(output_files, group_fn)
            output_sizes <- c(output_sizes, nrow(group_db))
            write_rearrangement(group_db, file=group_fn)
        }
    } else {
        write_rearrangement(db, file=output_fn)
    }
}
```


```{r log}
cat("START>ClonePass", file=log_fn, append=F)
cat(paste0("\nFILE> ",basename(params$input)), file=log_fn, append=T)
if (length(output_files==1)) {
    cat(paste0("\nOUTPUT> ",basename(output_fn)), file=log_fn, append=T)
    cat(paste0("\nPASS> ",nrow(db)), file=log_fn, append=T)
} else {
    for (i in 1:length(output_files)) {
        cat(paste0("\nOUTPUT",i,"> ",output_files[i]), file=log_fn, append=T)
        cat(paste0("\nPASS",i,"> ",output_sizes[i]), file=log_fn, append=T)
    }
}
cat(paste0("\nPASS> ",sum(output_sizes)), file=log_fn, append=T)
cat(paste0("\nFAIL> ",input_size-sum(output_sizes)), file=log_fn, append=T)
```


```{r, child=c('versions.Rmd')}
```


