--- 
title: "Immcantation - enchantR"
subtitle: "Dowser lineage"
author: ""
date: "Updated: `r date()`"
knit: enchantr::render_book
site: bookdown::bookdown_site
documentclass: book
bibliography: "references.bib"
biblio-style: apalike
link-citations: yes
description: "dowser build lineage trees"
output: enchantr::immcantation
params:
   input: 
      label: "`input`: Path to repertoires file"
      input: file
      value: "input.tsv" # this has been tested and build using the example data Hailong sent. It will break if that is not used in it's current state. It was also an RDS file, but the current pipeline wants a tsv so the code runs current wants a tsv. If you want to check with his data, change the read_rearrangment call to readRDS. 
   build:
       label: "`build`"
       input: text
       value: "igphyml"
   exec:
       label: "`exec`"
       input: text
       value: "/usr/local/share/igphyml/src/igphyml"
   minseq:
       label: "`minseq`"
       input: numeric
       value: 5
   traits:
       label: "`traits`"
       input: text
       value: "day"            
   tips:
       label: "`tips`"
       input: text
       value: "day"       
   outname:
      label: "`outname`"
      input: text
      value: "define-clones"
   nproc:
      label: "`nproc`"
      input: numeric
      value: 1
   num_fields:
      label: "`num_fields`"
      input: text
      value: "duplicate_count, consensus_count"
   chain:
      label: "`chain`"
      input: text
      value: "H"
   cell:
      label: "`cell`"
      input: text
      value: "cell_id_unique"
   heavy:
      label: "`heavy`"
      input: text
      value: "IGH"
   collapse:
      label: "`collapse`"
      input: logical
      value: TRUE
   columns:
      label: "`columns`"
      input: text
      value: ""
   log:
      label: "`log`"
      input: text
      value: "command_log"
   outdir:
      label: '`outdir`: Output directory'
      input: text
      value: !r file.path(getwd(),'enchantr')
   date: 
      label: '`date`: Run date'
      input: date
      value: !r format(Sys.time(), "%Y-%m-%d")
   logo:
      label: "`logo`: Path to report logo"
      input: file
      value: !r file.path("assets", "logo.png")
   logolink:
      label: "`logolink`: URL to be added to the logo"
      input: text
      value: "immcantation.org"
   echo: 
      label: '`echo`: Show code in the report.'
      input: checkbox
      value: TRUE
   cache:
      label: '`cache`: Use cached results'
      input: checkbox
      value: FALSE
editor_options: 
  chunk_output_type: console
---

```{r global-options, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(fig.width=7, fig.height=4, fig.path = "figures/",
                      echo=params$echo,cache=params$cache,
                      warning=FALSE, message=FALSE,
                      eval.after="fig.cap",
                      out_dir=params$outdir,
                      eval.opts = c('eval', 'echo', 'fig.height', 'fig.width'))

# Libraries
suppressPackageStartupMessages(library("enchantr"))
suppressPackageStartupMessages(library("DT"))
suppressPackageStartupMessages(library("dplyr"))
suppressPackageStartupMessages(library("airr"))
suppressPackageStartupMessages(library("alakazam"))
suppressPackageStartupMessages(library("shazam"))
suppressPackageStartupMessages(library("scoper"))
suppressPackageStartupMessages(library("dowser"))
suppressPackageStartupMessages(library("igraph"))


if (!dir.exists(params[['outdir']])) {
    dir.create(params[['outdir']], recursive = T)
}

file.copy(params$logo, 
          file.path(params$outdir,"assets", "logo.png"),
          recursive = T, overwrite=T)
```

# Input parameters

```{r input-parameters, results='asis'}
printParams(params)
```
```{r echo=FALSE, results='asis'}
print_table_caption(tag="input", text="Input parameters.")
save(params, file=file.path(params$outdir,"params.RData"))
```

# Read repertoires


```{r read-repertoires}
# Read repertoire
db <- bind_rows(lapply(strsplit(params[['input']],",")[[1]], function(x) {
    # Check input file
    if (!file.exists(x)) {
        stop(paste0("File ", basename(x), " doesn't exist."))
    }
  # update later for new data
    read_rearrangement(x)}
))
input_size <- nrow(db)
```

# Formatting clones

```{r formatClones}
h <- isHeavyChain(db[['locus']]) #IGH, TRB, TRD
if ((sum(h)>0 & params$chain!="L") || (params$chain == "L" & nrow(db[db[['locus']] != params[['heavy']],]))) {
    heavy <- unique(db[['locus']][h])
    if (length(heavy)>1) {
        stop("multiple heavy chain locus found.")
    } 
    
    clones <- data.frame()
    
    traits <- params[['traits']]
    if (!is.null(traits)) {
        validTraits <- function(traits, db) {
            trait_exists <- sapply(traits, function(x) { 
                x %in% colnames(db)}
            )
            if (any(!trait_exists)) {
                message("Ignoring non-existing traits: ",paste(traits[!trait_exists], collapse = ", "))
                traits <- traits[trait_exists]
            }
            if (length(traits) == 0 ) { 
                traits <- NULL
                return (traits)
            }
            traits
        }
        traits <- validTraits(traits, db)
    }
    
    # Convert NA traits to "missing"
    miss <- function(x) {
        ifelse(is.na(x), "missing",x)
    }
    db <- db %>%
        mutate(across(all_of(c(traits)), miss)) 
    
    num_fields <- params[['num_fields']]
    if (!is.null(num_fields)) {
      validNumFields <- function(num_fields, db) {
        num_fields_split <- strsplit(num_fields, ", ")[[1]]
        num_fields_exists <- sapply(num_fields_split, function(x) {
          x %in% colnames(db)}
        )
        if (any(!num_fields_exists)) {
          message("Ignoring non-existing num_fields: ",paste(num_fields_split[!num_fields_exists], collapse = ", "))
        }
        num_fields <- num_fields_split[num_fields_exists]
        if (length(num_fields) == 0) {
            num_fields <- NULL
            return (num_fields)
        }
        num_fields
      }
      num_fields <- validNumFields(num_fields, db)
    }
    
    columns <- params[['columns']]
    if(is.null(columns)){
      columns <- NULL
    } else {
      validColumns <- function(columns, db){
        columns_split <- strsplit(columns, ", ")[[1]]
        columns_exists <- sapply(columns_split, function(x) {
          x %in% colnames(db)}
        )
        if (any(!columns_exists)) {
          message("Ignoring non-existing num_fields: ",paste(columns_split[!columns_exists], collapse = ", "))
        }
        columns <- columns_split[columns_exists]
        if (length(columns) == 0) {
            columns <- NULL
            return (columns)
        }
        columns
      }
      columns <- validNumFields(columns, db)
    }

    try (
        clones <- formatClones(db,
                               traits=traits,
                               num_fields=num_fields,
                               chain=params$chain,
                               locus='locus',
                               heavy=params$heavy,
                               cell=params$cell,
                               minseq=params$minseq, 
                               nproc=params$nproc,
                               collapse=params$collapse,
                               columns=columns) 
    )
}  else {
      cat("All clones have less than minseq = ",params$minseq," sequences.")
  }
```

```{r getTrees}
if (nrow(clones)>0) {
    trees <- getTrees(clones, 
                      build=params$build, 
                      exec=params$exec,
                      nproc=params$nproc)
    
    if ( params$tips %in% colnames(db) ) {
        tips <- params$tips
    } else {
        tips <- NULL
    }
}
```

```{r plotTrees}
      plots <- plotTrees(trees, tips=tips, tipsize=2)
      for (i in 1:length(plots)) {
          cat(paste0("## Tree ",i,"\n\n"))
          print(plots[[i]])
          cat("\n\n")
      }

      # Saving all trees in a PDF
      treesToPDF(plots, file.path(params$outdir, "all_trees.pdf"))

      # Converting trees to graphs
      graphs = lapply(trees$trees, phyloToGraph, germline="Germline")
      names(graphs) <- trees$clone_id

      # Saving all trees in graphML format
      lapply(names(graphs), function(x) igraph::write.graph(file = file.path(params$outdir, paste("clone_", x, ".graphml", sep="")), graph=graphs[[x]], format="graphml"))
print(plots[[1]])
```


# Versions

```{r, child=c('versions.Rmd')}
```


# Log

```{r log}

if (!is.null(params$log)) {
    log_fn <- paste0(params$log,".txt")
} else {
    log_fn <- sub("_clone-pass.tsv$", "_command_log.txt", basename(output_fn))
}


cat("START>DowserPass", file=log_fn, append=F)
cat(paste0("\nFILE> ",basename(params$input)), file=log_fn, append=T)
cat(paste0("\nOUTPUT> ",basename(params$input)), file=log_fn, append=T)
cat(paste0("\nPASS> ",nrow(db)), file=log_fn, append=T)
#cat(paste0("\nFAIL> ",input_size-sum(output_sizes)), file=log_fn, append=T)
```
