--- 
title: "Immcantation - enchantR"
subtitle: "Find Threshold"
author: ""
date: "Updated: `r date()`"
knit: enchantr::render_book
site: bookdown::bookdown_site
documentclass: book
bibliography: "references.bib"
biblio-style: apalike
link-citations: yes
description: "enchantr single cell qc report"
output: enchantr::immcantation
params:
   input: 
      label: "`input`: Path to repertoires file"
      input: file
      value: "input.tsv"
   cloneby:
      label: "`cloneby`"
      input: text
      value: "sample_id"   
   crossby:
      label: "`crossby`"
      input: text
      value: "sample_id"
   singlecell:
      label: "`singlecell`"
      input: text
      value: "single_cell"          
   subsample:
      label: "`subsample`"
      input: numeric
      value: 0
   outname:
      label: "`outname`"
      input: text
      value: "find-threshold"
   nproc:
      label: "`nproc`"
      input: numeric
      value: 1      
   log:
      label: "`log`"
      input: text
      value: "command_log"
   outdir:
      label: '`outdir`: Output directory'
      input: text
      value: !r file.path(getwd(),'enchantr')
   date: 
      label: '`date`: Run date'
      input: date
      value: !r format(Sys.time(), "%Y-%m-%d")
   logo:
      label: "`logo`: Path to report logo"
      input: file
      value: !r file.path("assets", "logo.png")
   logolink:
      label: "`logolink`: URL to be added to the logo"
      input: text
      value: "immcantation.org"
   echo: 
      label: '`echo`: Show code in the report.'
      input: checkbox
      value: TRUE
   cache:
      label: '`cache`: Use cached results'
      input: checkbox
      value: FALSE
editor_options: 
  chunk_output_type: console
---

```{r global-options, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(fig.width=7, fig.height=4, fig.path = "figures/",
                      echo=params$echo,cache=params$cache,
                      warning=FALSE, message=FALSE,
                      eval.after="fig.cap",
                      out_dir=params$outdir,
                      eval.opts = c('eval', 'echo', 'fig.height', 'fig.width'))

# Libraries
suppressPackageStartupMessages(library("enchantr"))
suppressPackageStartupMessages(library("DT"))
suppressPackageStartupMessages(library("dplyr"))
suppressPackageStartupMessages(library("airr"))
suppressPackageStartupMessages(library("alakazam"))
suppressPackageStartupMessages(library("shazam"))
suppressPackageStartupMessages(library("tidyr"))
suppressPackageStartupMessages(library("plotly"))

if (!dir.exists(params[['outdir']])) {
    dir.create(params[['outdir']], recursive = T)
}

file.copy(params$logo,
          file.path(params$outdir,"assets", "logo.png"),
          recursive = T, overwrite=T)
```

# Input 

## Parameters


```{r input-parameters, results='asis'}
printParams(params)
```
```{r echo=FALSE, results='asis'}
print_table_caption(tag="input", text="Input parameters.")
save(params, file=file.path(params$outdir,"params.RData"))
```

## Input repertoires

```{r}
# Read repertoires, 
# keep only needed columns
selected_columns <- unique(c("sample_id", "sequence_id", 
                      params$cloneby,
                      params$crossby,
                      "v_call", "j_call", "junction", 
                      "cell_id", params$singlecell, "locus"))
db <- readInput(params[['input']], col_select=selected_columns)
input_sizes <- db %>%
    count(input_file)
eetable(input_sizes)$table
```

```{r}
input_size <- nrow(db)
is_heavy <- isHeavyChain(db[['locus']])

na_single <- is.na(db[[params$singlecell]])
if (sum(na_single)>0) {
    warning(sum(na_single), " sequences are missing single cell information. Using single_cell=F")
    db[[params$singlecell]][na_single] <- FALSE
}
db[[params$singlecell]] <- as.logical(db[[params$singlecell]])

bulk_heavy <- is_heavy & !db[[params$singlecell]]
sc_heavy <- is_heavy & db[[params$singlecell]]
bulk_dtn <- data.frame()
sc_dtn <- data.frame()
subsample <- params[['subsample']]
if (subsample %in% c(NA, 0, NULL)) {
    subsample <- NULL
}
```

Number of sequences loaded: `r input_size`.

```{r, results='asis'}
input_summary <- db %>%
   group_by(!!!rlang::syms(unique(c("sample_id",params$cloneby, "locus")))) %>%
   summarize(n=n(), .groups="drop") %>%
       pivot_wider(names_from=locus, values_from=n)

input_summary_table <- eetable(input_summary) 
input_summary_table$table
```
```{r echo=FALSE,results='asis'}
print_table_caption(tag="input_summary", text="Input data summary.")
```

# Distance to nearest


Clonal relationships can be inferred from sequencing data. Hierarchical clustering is a widely used method for identify clonally related sequences. This method requires a measure of distance between pairs of sequences and a choice of linkage to define the distance between groups of sequences. Since the result will be a tree, a threshold to cut the hierarchy into discrete clonal groups is also needed.

`shazam` provides methods to calculate the distance between sequences and find an appropriate distance threshold for each dataset (`distToNearest` and `findThreshold`). The threshold can be determined by analyzing the distance to the nearest distribution. This is the set of distances between each sequence and its closest non-identical neighbour.

`distToNearest` first splits sequences into groups that share the same V and J gene assignments and that have the same junction (or equivalently CDR3) length. This is based on the assumption that members of a clone will share all of these properties. `distToNearest` performs this grouping step, then counts the number of mismatches in the junction region between all pairs of sequences in each group and returns the smallest non-zero value for each sequence. At the end of this step, a new column (`dist_nearest`) which contains the distances to the closest non-identical sequence in each group will be added to db.

Typically, the distance-to-nearest distribution for a repertoire is bimodal. The first mode (on the left) represents sequences that have at least one clonal relative in the dataset, while the second mode (on the right) is representative of the sequences that do not have any clonal relatives in the data (sometimes called "singletons"). A reasonable threshold will separate these two modes of the distribution. In this case, it is easy to manually determine a threshold as a value intermediate between the two modes. However, `findThreshold` can be used to automatically find the threshold.

Specifying the `cross` argument to `distToNearest` forces distance calculations to be performed across groups, such that the nearest neighbor of each sequence will always be a sequence in a different group.
This measurement is particularly useful when the distance-to-nearest distribution is not a clear bimodal. Because the cross distance-to-nearest represents distances to extern groups, they will typically
be larger than the distances to sequences in the same group, and the distribution of the cross distance-to-nearest values will facilitate the identification of the second mode of the bimodal.


```{r sum_heavy_0, eval=sum(is_heavy)==0, echo=sum(is_heavy)==0, results='asis'}
cat("0 heavy chain sequences present. `distToNearest` requires heavy chain data. Setting `dist_neartest` to 'NA'")
db$dist_nearest <- NA
```

```{r distToNearest_bulk, eval=(any(db[[params$singlecell]] == F) && sum(bulk_heavy)>0) }
if (any(db[[params$singlecell]] == F) && sum(bulk_heavy)>0) {
    message("Using ",sum(bulk_heavy), " bulk heavy chain sequences.")
    bulk_dtn <- distToNearest(db[bulk_heavy,] , 
                               fields=params$cloneby,
                               sequenceColumn="junction", 
                               vCallColumn="v_call", jCallColumn="j_call",
                               model="ham", first=FALSE, VJthenLen=TRUE, normalize="len",
                               nproc=params$nproc,
                               subsample = subsample)
    
    bulk_dtn <- distToNearest(bulk_dtn, 
                               fields=NULL,
                               cross=params$crossby,
                               sequenceColumn="junction", 
                               vCallColumn="v_call", jCallColumn="j_call",
                               model="ham", first=FALSE, VJthenLen=TRUE, normalize="len",
                               nproc=params$nproc,
                               subsample = subsample)
        
} 
```

```{r distToNearest_single, eval=(any(db[[params$singlecell]] == T) && sum(sc_heavy)>0) }
if (any(db[[params$singlecell]] == T) && sum(sc_heavy)>0) {
    message("Using ",sum(sc_heavy), " sc heavy chain sequences.")
    # Create unique cell_id
    # db[['cell_id']] <- paste0(db[['sample_id']],db[['cell_id']])
    sc_dtn <- distToNearest(db[sc_heavy,] , 
                          fields=params$cloneby,
                          sequenceColumn="junction", 
                          vCallColumn="v_call", jCallColumn="j_call",
                          model="ham", first=FALSE, VJthenLen=TRUE, normalize="len",
                          nproc=params$nproc,
                          cellIdColumn = "cell_id",
                          locusColumn = "locus",
                          onlyHeavy = TRUE,
                          subsample = subsample)
    sc_dtn <- distToNearest(sc_dtn, 
                          fields=NULL,
                          cross=params$crossby,
                          sequenceColumn="junction", 
                          vCallColumn="v_call", jCallColumn="j_call",
                          model="ham", first=FALSE, VJthenLen=TRUE, normalize="len",
                          nproc=params$nproc,
                          cellIdColumn = "cell_id",
                          locusColumn = "locus",
                          onlyHeavy = TRUE,
                          subsample = subsample)    
} 
```

## `distToNearest` plot

```{r dtnplot, fig.width=8, fig.height=max(4, nrow(unique(db[,c("sample_id", params$singlecell)], drop=F))/2), fig.cap=caption}

caption <- paste0("Distribution of the distance to the nearest sequence within ",
            paste(params$cloneby, collapse=","),", displayed by sample_id. When ",
            "cross ",paste(params$crossby, collapse=","),
            " distances are available, they are shown in an inverse y-axis.")
if (!is.null(subsample)) {
    caption <- paste0(caption," Subsampling requested: ", subsample, ".")
}

wrap_formula <- as.formula(paste0(
                        c(
                            params$singlecell,
                            "~",
                            paste(unique(c("sample_id", params$clone_by)), collapse = "+")
                        ),collapse="")
)
db <- bind_rows(bulk_dtn,sc_dtn)

dtnplot <- NULL

if (any(!is.na(db[['dist_nearest']]))) {
    dtnplot <- ggplot(db) +
        geom_histogram(aes(dist_nearest, fill=sample_id),binwidth = 0.01) +
        scale_x_continuous(
            breaks = seq(0, 1, 0.1)
        )
} else {
    cat("All `dist_nearest` values are NA.")
    warning("All `dist_nearest` values are NA.")
}

if ("cross_dist_nearest" %in% c(colnames(bulk_dtn),colnames(sc_dtn))) {
   if (any(!is.na(db[['cross_dist_nearest']]))) {
    dtnplot <- dtnplot + 
        geom_histogram(
            aes(x=cross_dist_nearest, y=-(..count..), fill=sample_id), 
            binwidth=0.01, position="identity") +
            scale_y_continuous(labels = abs) +
            ylab("count")
   } else {
      cat("All `cross_dist_nearest` values are NA.")
      warning("All `cross_dist_nearest` values are NA.")
   }
}

if (is.null(dtnplot)) {
    cat("All distance values are NA.")
}
```

```{r showdtnplot, eval=!is.null(dtnplot), fig.cap=caption}
dtnplot <- dtnplot +
    facet_wrap(wrap_formula, scales = "free_y", ncol=2, labeller = "label_both") +
    expand_limits(x = 0, y =0) +
    theme_enchantr() +
    theme(legend.position = "bottom")

dtnplot <- eeplot(dtnplot, 
                  outdir=params$outdir, 
                  file=knitr::opts_current$get('dtnplot'),
                  caption=caption
)
ggplotly(dtnplot + theme(panel.spacing=unit(2, 'lines'), legend.position="none"))
caption <- dtnplot$enchantr$html_caption
```

## Find threshold

`findThreshold` uses the distribution of distances calculated in the previous step to determine an appropriate threshold for the dataset. 


### Theshold(s) summary table

```{r, eval=all(is.na(db[['dist_nearest']]))}
# This chunk runs when all dist_nearest values are NA
threshold <- NA
threshold_summary <- data.frame(mean_threshold = NA)
cat("All `dist_nearest` values are NA. Skipping threshold analysis.")
```

```{r threshold, eval=!all(is.na(db[['dist_nearest']])), results='asis'}
cross_dist_nearest <- NULL
if ("cross_dist_nearest" %in% colnames(db)) {
    if (any(!is.na(db[['cross_dist_nearest']]))) {
       cross_dist_nearest <- "cross_dist_nearest"
    } else {
       warning("All `cross_dist_nearest` values are NA.")
    }
}
threshold <- findThresholdDb(db, 
                            distanceColumn="dist_nearest", 
                            crossDistanceColumn=cross_dist_nearest,
                            method="gmm", 
                            model="gamma-norm",
                            edge = 0.9, subsample=NULL, 
                            cutoff = "user", spc = 0.995,
                            nproc=params$nproc, 
                            fields=params$cloneby,
                            subsample=subsample)

threshold_summary <- gmmSummary(threshold) %>%
    mutate(mean_threshold=mean(threshold, na.rm=TRUE))
mean_threshold <- round(threshold_summary$mean_threshold[1],2)

tab_caption <- paste0("Summary of threshold values. Mean threshold is: ", mean_threshold)
if (!is.null(subsample)) {
    tab_caption <- paste0(tab_caption," Subsampling requested: ", subsample, ".")
}

tab <- eetable(threshold_summary, 
               outdir=params$outdir, 
               file="threshold_summary",
               caption=tab_caption)  
tab$table %>%
        DT::formatRound(columns=setdiff(colnames(threshold_summary)[-1],"model"),
                    digits=3)
```
```{r echo=FALSE,eval=!all(is.na(db[['dist_nearest']])),results='asis'}
print_table_caption(tag="threshold_summary",text=tab$caption)
```

```{r, eval=!all(is.na(db[['dist_nearest']])), results='asis', fig.width=3.5, fig.height=3, fig.cap=caption_list}
caption_list <- NULL
tmp <- lapply(threshold, function(thr) {
    this_thr <- NA
    if (!is.null(attributes(thr$GmmThreshold))) {
        this_thr <- round(attributes(thr$GmmThreshold)$threshold,2)
    }
    cat ("\n\n### ",paste(c(thr[['fields']], ": ", this_thr),collapse=" "),"\n\n")
    fn <- paste(c(thr[['fields']],"dtnthrplot"),collapse="_")
    dtnthrcaption <- paste0("Distribution of the distance to the nearest sequence within ",
            paste(params$cloneby, collapse=",")," (",
            paste(thr[['fields']],collapse="_")
            ,"). When ",
            "cross ",paste(params$crossby, collapse=","),
            " distances are available, they are shown in an inverse y-axis.")
    p <- thr[['plot']] +
        scale_x_continuous(
            breaks = seq(0, 1, 0.1)
        )
    p <- eeplot(p, 
                  outdir=params$outdir, 
                  file=fn,
                  caption=dtnthrcaption
    )
    print(p)
    caption_list <<- c(caption_list, p$enchantr$html_caption)    
})
```

# Save

```{r dbpass}
# pass <- db[['collapse_pass']]

if (!is.null(params$outname)) {
    output_fn <- paste0(params$outname,"_threshold-pass.tsv")
} else {
    output_fn <- sub(".tsv$", "_threshold-pass.tsv", basename(params$input))
}

if (!is.null(params$log)) {
    log_fn <- paste0(params$log,".txt")
} else {
    log_fn <- sub("_threshold-pass.tsv$", "_command_log.txt", basename(output_fn))
}

# write_rearrangement(db , file=output_fn)
write.table(threshold_summary, 
            sub("_threshold-pass.tsv$", "_threshold-summary.tsv" ,output_fn),
            quote=FALSE,sep="\t", row.names=FALSE)
cat(threshold_summary[['mean_threshold']][1], 
    file=sub("_threshold-pass.tsv$", "_threshold-mean.tsv" ,output_fn),
    append=F
)
```

```{r log}
cat("START> FindThreshold", file=log_fn, append=F)
cat(paste0("\nFILE> ",basename(params$input)), file=log_fn, append=T)
cat(paste0("\nOUTPUT> ",basename(output_fn)), file=log_fn, append=T)
cat(paste0("\nPASS> ",nrow(db)), file=log_fn, append=T)
cat(paste0("\nFAIL> ",input_size-nrow(db)), file=log_fn, append=T)
```


```{r, child=c('versions.Rmd')}
```
