--- 
title: "Immcantation - enchantR"
subtitle: "Define Clones"
author: ""
date: "Updated: `r date()`"
knit: "bookdown::render_book"
site: bookdown::bookdown_site
documentclass: book
bibliography: "references.bib"
biblio-style: apalike
link-citations: yes
description: "enchantr define clones"
output: enchantr::immcantation
params:
   input: 
      label: "`input`: Path to repertoires files"
      input: file
      value: "input.tsv"
   imgt_db:
      label: "`imgt_db`: Path to IMGT reference  database."
      input: file
      value: !r NULL
   force:
      label: "`force`: if clone_id alreday exists, overwrite (force=TRUE) or skip clone assignment and render the report (force=FALSE)."
      input: logical        
      value: !r FALSE       
   cloneby:
      label: "`cloneby`"
      input: text
      value: "sample_id"    
   singlecell:
      label: "`singlecell`"
      input: text
      value: "single_cell"          
   threshold:
      label: "`threshold`"
      input: numeric
      value: 1
   min_n:
      label: "`min_n`"
      input: numeric
      value: 30
   outputby:
      label: "`outputby` name of the column in `input` that contains sample identifiers that will be used to split the output db."      
      input: text
      value: "id"
   model:
      label: "`model`"
      input: text
      value: "hierarchical" 
   method:
       label: "`method`"
       input: text
       value: "nt"
   linkage:
       label: "`linkage`"
       input: text
       value: "single"
   nboot:
       label: "`nboot`: number of bootstrap realizations to generate in `estimateAbundance`"
       input: numeric
       value: 200               
   outname:
      label: "`outname`"
      input: text
      value: "define-clones"
   nproc:
      label: "`nproc`"
      input: numeric
      value: 1      
   log:
      label: "`log`"
      input: text
      value: "command_log"
   outdir:
      label: '`outdir`: Output directory'
      input: text
      value: !r file.path(getwd(),'enchantr')
   date: 
      label: '`date`: Run date'
      input: date
      value: !r format(Sys.time(), "%Y-%m-%d")
   logo:
      label: "`logo`: Path to report logo"
      input: file
      value: !r file.path("assets", "logo.png")
   logolink:
      label: "`logolink`: URL to be added to the logo"
      input: text
      value: "immcantation.org"
   echo: 
      label: '`echo`: Show code in the report.'
      input: checkbox
      value: TRUE
   cache:
      label: '`cache`: Use cached results'
      input: checkbox
      value: FALSE
editor_options: 
  chunk_output_type: console
---


```{r global-options, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(fig.width=7, fig.height=4, fig.path = "figures/",
                      echo=params$echo,cache=params$cache,
                      warning=FALSE, message=FALSE,
                      eval.after="fig.cap",
                      out_dir=params$outdir,
                      eval.opts = c('eval', 'echo', 'fig.height', 'fig.width'))

# Libraries
suppressPackageStartupMessages(library("DT"))
suppressPackageStartupMessages(library("dplyr"))
suppressPackageStartupMessages(library("tidyr"))
suppressPackageStartupMessages(library("airr"))
suppressPackageStartupMessages(library("alakazam"))
suppressPackageStartupMessages(library("shazam"))
suppressPackageStartupMessages(library("scoper"))
suppressPackageStartupMessages(library("dowser"))
suppressPackageStartupMessages(library("enchantr"))

if (!dir.exists(params[['outdir']])) {
    dir.create(params[['outdir']], recursive = T)
}

file.copy(params$logo, 
          file.path(params$outdir,"assets", "logo.png"),
          recursive = T, overwrite=T)
```


# Input parameters

```{r input-parameters, results='asis'}
printParams(params)
```
```{r echo=FALSE, results='asis'}
print_table_caption(tag="input", text="Input parameters.")
save(params, file=file.path(params$outdir,"params.RData"))
```

# Read repertoires

```{r}
# Read repertoire
db<- bind_rows(lapply(strsplit(params[['input']],",")[[1]], function(x) {
    # Check input file
    if (!file.exists(x)) {
        stop(paste0("File ", basename(x), " doesn't exist."))
    }
    # Make _length fields numeric
    aux_cols <- c("v_germline_length"="numeric",
                  "d_germline_length"="numeric",
                  "j_germline_length"="numeric")
    read_rearrangement(x, aux_types=aux_cols)

}))
db[[ params$singlecell ]] <- as.logical(db[[ params$singlecell ]] )
input_size <- nrow(db)
if (!"locus" %in% colnames(db)) {
    db[['locus']] <- getLocus(db[['v_call']])
}
heavy_chains <- isHeavyChain(db[['locus']]) #IGH, TRB, TRD

if ("clone_id" %in% colnames(db)) {
    if (params$force) {
        # Reset if force
        warning("Overwritting clone_id.")
        db$clone_id <- NULL
    }   
    # Reset always if clone_id exists
    if ("clone_size_count" %in% colnames(db)) {    
        warning("Overwritting clone_size_count.")    
        db$clone_size_count <- NULL
    }
    if ("clone_size_freq" %in% colnames(db)) {    
        warning("Overwritting clone_size_freq.")    
        db$clone_size_freq <- NULL
    }    
}
```

Number of sequences loaded: `r input_size`. Number of heavy chain sequences loaded: `r sum(heavy_chains, na.rm=T)`.

```{r inputsamplesumary, results='asis'}
input_samples_summary <- db %>%
   group_by(sample_id, subject_id, tissue) %>%
   summarize(size = n()) %>%
   arrange(subject_id)

eetable(input_samples_summary)$table
```
```{r echo=FALSE, results='asis'}
print_table_caption(tag="input_samples_summary", text="Input samples summary.")
```


## Sequences per locus

```{r inputlocussumary, results='asis'}
input_locus_summary <- db %>%
   group_by(!!!rlang::syms(unique(c("sample_id",params$cloneby, "locus")))) %>%
   summarize(n=n(), .groups="drop") %>%
   pivot_wider(names_from=locus, values_from=n) %>%
   rowwise() %>%
   mutate(Total = sum(!!!rlang::syms(unique(db[['locus']]))))

total <- data.frame(list("sample_id"="Total", 
                    t(input_locus_summary %>%
   select(!!!rlang::syms(c(unique(db[['locus']]), "Total"))) %>%
   colSums(na.rm = T))))

input_locus_summary <- bind_rows(input_locus_summary, total)

tab_caption <- paste0("Input data. Number of sequences in each ", 
                   paste("sample", params$cloneby, sep=", "),
                   " and locus."
      )
eetable(input_locus_summary)$table
```
```{r echo=FALSE,results='asis'}
print_table_caption(tag="input_locus_summary", text=tab_caption)
```

```{r eval="c_call" %in% colnames(db), results='asis'}
cat("## Sequences per c_call\n")
```

```{r input-ccall-sumary, eval="c_call" %in% colnames(db), results='asis'}
input_c_call_summary <- db %>%
   group_by(!!!rlang::syms(unique(c("sample_id",params$cloneby, "c_call")))) %>%
   summarize(n=n(), .groups="drop") %>%
       pivot_wider(names_from=c_call, values_from=n)

tab_caption <- paste0("Input data. Number of sequences in each ", 
                   paste("sample", params$cloneby, sep=", "),
                   " and c_call"
      )
eetable(input_c_call_summary)$table
```
```{r echo=FALSE, results='asis'}
print_table_caption(tag="input_c_call_summary", text=tab_caption)
```

# Clonal assignment

```{r, eval="clone_id" %in% colnames(db), results='asis', echo=FALSE}
cat("\n\nThe input data contains clonal assingments, and are being reused.")
```

```{r, child=c('run_scoper.Rmd'), eval=!"clone_id" %in% colnames(db)}
```

# Summary of clonal assignment

Description of terms:

* `clone_size_count`: Clone size as sequence counts. In a sample (`sample_id`), the number of heavy chain 
sequences with the same `clone_id`.

* `clone_size_freq`: Clone size as percent of the repertoire. `clone_size_count` divided by the number of heavy chain sequences in the sample (`sample_id`).


## Number of clones (heavy chain, incl. singletons)

```{r}
# Add clone_size 
clone_sizes <- countClones(
            db %>% filter(isHeavyChain(locus)), # Keep heavy chains only
            groups=unique(c("sample_id", params$cloneby)))

db <- db %>%
   left_join(clone_sizes) %>%
   rename(
      clone_size_count = seq_count,
      clone_size_freq = seq_freq
   ) %>% 
   mutate_at(vars(starts_with("clone_size")), round,2)
```

```{r, results='asis'}
num_clones_table <- db %>%
   filter(isHeavyChain(locus)) %>% # Keep heavy chains only
   group_by(sample_id) %>%
   mutate(sequences=n()) %>%
   group_by(sample_id) %>%
   mutate(
      number_of_clones=length(unique(clone_id)),
   ) %>%
   group_by(!!!rlang::syms(unique(c("sample_id","sequences", params$cloneby, "number_of_clones")))) %>%
   summarize_at(vars(starts_with("clone_size")), list("min"=min, "median"=median, "max"=max)) %>%
   mutate_at(vars(starts_with("clone_size")), round, 2)

tab_caption <- "Summary of the number of clones, and clone size, per sample. Includes singletons (clone_size == 1)."
tab <- eetable(num_clones_table, caption=tab_caption, outdir=params$outdir, file="num_clones_table")
tab$table
```
```{r echo=FALSE, results='asis'}
print_table_caption(tag="num_clones_table", text=tab$caption)
```

## Expanded clones within `sample_id` (heavy chain, without singletons)

```{r, results='asis'}
num_clones_table_nosingle <- db %>%
   filter(isHeavyChain(locus)) %>% # Keep heavy chains only
   filter(clone_size_count>1) %>%
   group_by(sample_id) %>%
   mutate(sequences=n()) %>%
   group_by(sample_id) %>%
   mutate(
      number_of_clones=length(unique(clone_id)),
   ) %>%
   group_by(!!!rlang::syms(unique(c("sample_id","sequences", params$cloneby, "number_of_clones")))) %>%
   summarize_at(vars(starts_with("clone_size")), list("min"=min, "median"=median, "max"=max)) %>%
   mutate_at(vars(starts_with("clone_size")), round, 2)

tab_caption <- "Summary of the number of clones of size > 1, and their clone sizes, per sample."
tab <- eetable(num_clones_table_nosingle, caption = tab_caption, outdir=params$outdir, file="num_clones_table_nosingle")
tab$table
```
```{r echo=FALSE,results='asis'}
print_table_caption(tag="num_clones_table_nosingle", text=tab_caption)
```

## Expanded clones within `r paste(params$cloneby,collapse=", ")`

```{r, results='asis'}
any_tissues <- db %>%
   filter(isHeavyChain(locus)) %>% # Keep heavy chains only
   group_by(!!!rlang::syms(c("clone_id", params$cloneby))) %>%
   summarize(
             clone_size_group_count=n(),
             num_tissues=length(unique(tissue)),
             tissues=paste(sort(unique(tissue)),collapse=" & "), .groups="drop") %>%
   filter(clone_size_group_count>1) %>%
   group_by(!!!rlang::syms(c("tissues", params$cloneby))) %>%
   summarize(num_clones=length(unique(clone_id)))
    
tab_caption <- paste0("Summary of expanded clones in ", paste(params$cloneby, collapse = ", "), " . Subsetting to clones of size > 1 in the cloning group (not the sample).")
eetable(any_tissues, caption=tab_caption)$table
```
```{r echo=FALSE, results='asis'}
print_table_caption(tag="any_tissues", text=tab_caption)
```

## Clones spanning multiple tissues

```{r, results='asis'}
multi_tissue <- db %>%
    filter(isHeavyChain(locus)) %>% # Keep heavy chains only
    group_by(!!!rlang::syms(c(params$cloneby, "clone_id"))) %>%
    summarize(num_tissues=length(unique(tissue))) %>%
    filter(num_tissues>1)

multi_tissue <- multi_tissue %>%
   left_join(db %>% filter(isHeavyChain(locus)), 
   by=c("clone_id", params$cloneby)) %>%
   select(!!!rlang::syms(unique(c("clone_id", "tissue", "sample_id", "clone_size_count", "clone_size_freq", params$clone_by, "sequence_id")))) %>%
   group_by(!!!rlang::syms(c("clone_id", "clone_size_count", "clone_size_freq","tissue", "sample_id", params$clone_by))) %>%
   summarize(seq_count=n())

tab_caption <- "Summary of clones spanning more than one tissue."
eetable(multi_tissue, caption=tab_caption)$table
```
```{r echo=FALSE, results='asis'}
print_table_caption(tag="multi_tissue", text=tab_caption)
```

# Clone size distribution

Most real datasets, will have most clones of size 1 (one sequence). Straight sequence count as a mesure of the size of the clones is not the best measure
to compare clone size between samples. See [Clonal abundance](#clonal_abundance)

```{r clone-size, fig.width=8, fig.height=0.7*length(unique(db[['sample_id']]))}
ggplot(clone_sizes, aes(x=seq_count, color=sample_id, fill=sample_id))+
    geom_bar() + theme_bw() +
    facet_wrap(~sample_id, scales = "free_y", ncol=3) +
    xlab("Clone size (Number of sequences per clone)")
```

## Subset to clone size > 1

```{r clone-size-atleast2, fig.width=8, fig.height=0.7*length(unique(db[['sample_id']]))}
ggplot(clone_sizes %>% filter(seq_count>1), aes(x=seq_count, color=sample_id, fill=sample_id))+
    geom_bar() + theme_bw() +
    facet_wrap(~sample_id, scales = "free_y", ncol=3) +
    xlab("Clone size (Sequences per clone)")
```


# Clonal abundance {#clonal_abundance}

Clonal abundance is the size of each clone (as a fraction of the entire repertoire). To correct for the different number of sequences in each of the samples, `estimateAbundance` estimates the clonal abundance distribution along with confidence intervals on these clone sizes using bootstrapping. `r params$nboot` random bootstrap samples were taken, with size the number of sequences in the sample with less sequences (N). The y-axis shows the clone abundance (i.e., the size as a percent of the repertoire) and the x-axis is a rank of each clone, where the rank is sorted by size from larger (rank 1, left) to smaller (right). The shaded areas are confidence intervals.

```{r abundancebysample, results='asis'}
# calculate the rank-abundance curve
a <- estimateAbundance(db %>% filter(isHeavyChain(locus)),
                       group = "sample_id", min_n = params$min_n)
if (nrow(a@abundance)==0) {
    cat("\nAll groups failed to pass the threshold min_n=",params$min_n,". Skipping clonal abundance report.\n\n")
}
```

```{r, child=c('abundance.Rmd'), eval=nrow(a@abundance)>0}
```

# `junction` and `junction_aa` overlap

Similarity of the junction sequence is sometimes used as a proxy of antibody convergence.

## Same sequence

Identity of the `junction` and `junction_aa` heavy chain sequences between `sample_id`.

```{r overlap}
overlap <- plotDbOverlap(db %>% 
                         filter(isHeavyChain(locus)), 
                         group="sample_id", 
                         features=c("junction_aa","junction"), 
                         heatmap_colors=c("white","orange", "grey80"), 
                         print_zero=FALSE, long_x_angle=90,
                         title=NULL,xlab=NULL, ylab=NULL,
                         plot_order=c("tissue","sample_id"), 
                         silent=T, similarity=c("min","min"),
                         na.rm=FALSE, 
                         identity=c('ham_aa', 'ambiguous'), 
                         threshold=0,
                         geom_text_size=3) 
```

```{r overlapplot, fig.width=min(10,max(5,0.5*length(unique(db[['sample_id']])))), fig.height=min(10,max(5,0.5*length(unique(db[['sample_id']])))),fig.cap=caption}
caption <- "Number of shared nt and aa heavy chain junction unique sequences. The percent represents the number of shared sequences over the number of sequences in the smaller set."
overlapplot <- overlap$p
overlapplot <- eeplot(overlapplot, 
       outdir=params$outdir, 
       file=knitr::opts_current$get('label'),
       caption=caption
       )
overlapplot
caption <- overlapplot$enchantr$html_caption
```

## Threshold (`r round(params$threshold,3)`)

Similarity of the `junction` and `junction_aa` heavy chain sequences between `sample_id`.

```{r overlapthr}
overlap_thr <- plotDbOverlap(db %>% 
                         filter(isHeavyChain(locus)), 
                         group="sample_id", 
                         features=c("junction_aa","junction"), 
                         heatmap_colors=c("white","orange", "grey80"), 
                         print_zero=FALSE, long_x_angle=90,
                         title=NULL,xlab=NULL, ylab=NULL,
                         plot_order=c("tissue","sample_id"), 
                         silent=T, similarity=c("min","min"),
                         na.rm=FALSE, 
                         identity=c('ham_aa', 'ham_nt'), 
                         threshold=round(params$threshold,3),
                         geom_text_size=3) 
```

```{r overlapthrplot, fig.width=min(10,max(5,0.5*length(unique(db[['sample_id']])))),  fig.height=min(10,max(5,0.5*length(unique(db[['sample_id']])))), fig.cap=caption}
caption <- paste0("Number of similar nt and aa heavy chain junction unique sequences. Two sequences are similar if their hamming distance is <=",round(params$threshold,3), ". The percent represents the number of similar sequences over the number of sequences in the smaller set.")
overlapthrplot <- overlap_thr$p
overlapthrplot <- eeplot(overlapthrplot, 
       outdir=params$outdir, 
       file=knitr::opts_current$get('label'),
       caption=caption)
overlapthrplot
caption <- overlapthrplot$enchantr$html_caption
```

# Final repertoires and tables

Summary tables:

```{r, results='asis', echo=FALSE}
cat("- [Number of clones](num_clones_table.tsv)\n", sep="")
```
```{r, results='asis', echo=FALSE, eval=nrow(a@abundance)>0}
cat("- [Clonal abundance](clonal_abundance.tsv)\n", sep="")
cat("- [Clonal diversity](clonal_diversity.tsv)\n", sep="")
```

Find your final repertoires here:

```{r dbpass, results='asis', echo=F}
# pass <- db[['collapse_pass']]

if (!is.null(params$outname)) {
    output_fn <- paste0(params$outname,"_clone-pass.tsv")
} else {
    output_fn <- sub(".tsv$", "_clone-pass.tsv", basename(params$input))
}

if (!is.null(params$log)) {
    log_fn <- file.path(params$outdir,paste0(params$log,".txt"))
} else {
    log_fn <- file.path(params$outdir,sub("_clone-pass.tsv$", "_command_log.txt", basename(output_fn)))
}

output_files <- c()
output_sizes <- c()
if (sum(heavy_chains)>0 & nrow(db)>0) {
    
    output_groups <- db %>%
        ungroup() %>%
        select(!!!rlang::syms(params$outputby)) %>%
        distinct() 
    
    if (nrow(output_groups)>0) {
        for (i in 1:nrow(output_groups))  {
            group_db <- right_join(db,
                                   output_groups[i,,drop=F],
                                   by=params$outputby)
            
            group_db_label <- gsub("^id_","",makeLabel(group_db, fields= params$outputby))
            group_fn <- file.path(params$outdir,paste0(group_db_label,"_",output_fn))
            output_files <- c(output_files, group_fn)
            output_sizes <- c(output_sizes, nrow(group_db))
            write_rearrangement(group_db, file=group_fn)
            cat("- [",group_db_label,"](",basename(group_fn),")\n", sep="")
        }
    } else {
        write_rearrangement(db, file=output_fn)
    }
}
```


```{r log, results='asis', echo=FALSE}
cat("START>ClonePass", file=log_fn, append=F)
cat(paste0("\nFILE> ",basename(params$input)), file=log_fn, append=T)
if (length(output_files==1)) {
    cat(paste0("\nOUTPUT> ",basename(output_fn)), file=log_fn, append=T)
    cat(paste0("\nPASS> ",nrow(db)), file=log_fn, append=T)
} else {
    for (i in 1:length(output_files)) {
        cat(paste0("\nOUTPUT",i,"> ",output_files[i]), file=log_fn, append=T)
        cat(paste0("\nPASS",i,"> ",output_sizes[i]), file=log_fn, append=T)
    }
}
cat(paste0("\nPASS> ",sum(output_sizes)), file=log_fn, append=T)
cat(paste0("\nFAIL> ",input_size-sum(output_sizes)), file=log_fn, append=T)
```

```{r, child=c('versions.Rmd')}
```