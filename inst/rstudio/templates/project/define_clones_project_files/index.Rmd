--- 
title: "Immcantation - enchantR"
subtitle: "Define Clones"
author: ""
date: "Updated: `r date()`"
knit: "bookdown::render_book"
site: bookdown::bookdown_site
documentclass: book
bibliography: "references.bib"
biblio-style: apalike
link-citations: yes
description: "enchantr define clones"
output: enchantr::immcantation
params:
   input: 
      label: "`input`: Path to repertoires file"
      input: file
      value: "input.tsv"
   imgt_db:
      label: "`imgt_db`: Path to IMGT reference  database."
      input: file
      value: !r NULL
   cloneby:
      label: "`cloneby`"
      input: text
      value: "sample_id"    
   singlecell:
      label: "`singlecell`"
      input: text
      value: "single_cell"          
   threshold:
      label: "`threshold`"
      input: numeric
      value: 1
   outputby:
      label: "`outputby` name of the column in `input` that contains sample identifiers that will be used to split the output db."      
      input: text
      value: "id"
   model:
      label: "`model`"
      input: text
      value: "hierarchical" 
   method:
       label: "`method`"
       input: text
       value: "nt"
   linkage:
       label: "`linkage`"
       input: text
       value: "single"
   outname:
      label: "`outname`"
      input: text
      value: "define-clones"
   nproc:
      label: "`nproc`"
      input: numeric
      value: 1      
   log:
      label: "`log`"
      input: text
      value: "command_log"
   outdir:
      label: '`outdir`: Output directory'
      input: text
      value: !r file.path(getwd(),'enchantr')
   date: 
      label: '`date`: Run date'
      input: date
      value: !r format(Sys.time(), "%Y-%m-%d")
   logo:
      label: "`logo`: Path to report logo"
      input: file
      value: !r file.path("assets", "logo.png")
   logolink:
      label: "`logolink`: URL to be added to the logo"
      input: text
      value: "immcantation.org"
   echo: 
      label: '`echo`: Show code in the report.'
      input: checkbox
      value: FALSE
   cache:
      label: '`cache`: Use cached results'
      input: checkbox
      value: FALSE
editor_options: 
  chunk_output_type: console
---

```{r global-options, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(fig.width=7, fig.height=4, fig.path = "figures/",
                      echo=params$echo,cache=params$cache,
                      warning=FALSE, message=FALSE,
                      eval.after="fig.cap",
                      out_dir=params$outdir,
                      eval.opts = c('eval', 'echo', 'fig.height', 'fig.width'))

# Libraries
suppressPackageStartupMessages(library("enchantr"))
suppressPackageStartupMessages(library("DT"))
suppressPackageStartupMessages(library("dplyr"))
suppressPackageStartupMessages(library("airr"))
suppressPackageStartupMessages(library("alakazam"))
suppressPackageStartupMessages(library("shazam"))
suppressPackageStartupMessages(library("scoper"))
suppressPackageStartupMessages(library("dowser"))

file.copy(params$logo, 
          file.path(params$outdir,"assets", paste0("logo", gsub(".+(\\..+$)","\\1",params$logo))),
          recursive = T, overwrite=T)
```

# Input parameters

```{r input-parameters}
params
if (!dir.exists(params[['outdir']])) {
   dir.create(params[['outdir']], recursive = T)
}
save(params, file=file.path(params$outdir,"params.RData"))
```

# Read repertoires


```{r}

# Read repertoire
db <- bind_rows(lapply(strsplit(params[['input']],",")[[1]], function(x) {
    # Check input file
    if (!file.exists(x)) {
        stop(paste0("File ", basename(x), " doesn't exist."))
    }
    read_rearrangement(x)}
))
input_size <- nrow(db)
```

# Define Clones

```{r}
heavy_chains <- sum(grepl("[hHBbDc]", db[['locus']])) #IGH, TRB, TRD
if (sum(heavy_chains)>0) {
    if (params$model == "hierarchical") {
        if (all(db[[ params$singlecell ]] == T )) {
            cell_id <- 'cell_id'
        } else {
            cell_id <- NULL
            if (all(c(T,F) %in% db[[ params$singlecell ]])) {
                warning("Mix of single and bulk data. Setting cell_id=`NULL`.")
            }
        }
        db <- hierarchicalClones(db, 
                                 threshold=params$threshold, 
                                 method=params$method,
                                 linkage=params$linkage, 
                                 normalize="len",
                                 junction="junction", 
                                 v_call="v_call", j_call="j_call", 
                                 clone="clone_id", 
                                 fields=params$cloneby,
                                 cell_id=cell_id, 
                                 locus="locus", 
                                 only_heavy=FALSE, 
                                 split_light=TRUE,
                                 first=FALSE, 
                                 cdr3=FALSE, mod3=FALSE, 
                                 max_n=0, nproc=params$nproc,
                                 verbose=FALSE, log=NULL,
                                 summarize_clones=FALSE) 
    } else {
        stop("Unsuported model requested. Supported models: hierarchical")
    }
} else {
    warning("No heavy chain sequences found.")
    db$clone_id <- NA
}
```

# Create germlines

```{r}
if ( length(unique(db[['species']])) > 1 ) {
    message("Message: multiple species found.")
} 
db[['tmp_nrow']] <- 1:nrow(db)
db <- bind_rows(lapply(split(db,db[['species']]),
                 function(db_sp) { 
                     species <- db_sp[['species']][1]
                     references <- readIMGT(file.path(params[['imgt_db']], species, "vdj"))
                     bind_rows(lapply(split(db_sp, db_sp[['locus']]), 
                                            function(db_locus) {
                                                locus <- db_locus[['locus']][1]
                                                db_locus <- createGermlines(
                                                    db_locus,
                                                    references,
                                                    organism = species,
                                                    locus = locus,
                                                    nproc = params$nproc,
                                                    seq = "sequence_alignment",
                                                    v_call = "v_call",
                                                    d_call = "d_call",
                                                    j_call = "j_call",
                                                    amino_acid = FALSE,
                                                    id = "sequence_id",
                                                    clone = "clone_id",
                                                    v_germ_start = "v_germline_start",
                                                    v_germ_end = "v_germline_end",
                                                    v_germ_length = "v_germline_length",
                                                    d_germ_start = "d_germline_start",
                                                    d_germ_end = "d_germline_end",
                                                    d_germ_length = "d_germline_length",
                                                    j_germ_start = "j_germline_start",
                                                    j_germ_end = "j_germline_end",
                                                    j_germ_length = "j_germline_length",
                                                    np1_length = "np1_length",
                                                    np2_length = "np2_length",
                                                    na.rm = TRUE,
                                                    fields = params$cloneby,
                                                )
                                            }))
                 })) %>%
    arrange(tmp_nrow) %>%
    select(-tmp_nrow) 
```

# Save

```{r dbpass}
# pass <- db[['collapse_pass']]

if (!is.null(params$outname)) {
    output_fn <- paste0(params$outname,"_clone-pass.tsv")
} else {
    output_fn <- sub(".tsv$", "_clone-pass.tsv", basename(params$input))
}

if (!is.null(params$log)) {
    log_fn <- paste0(params$log,".txt")
} else {
    log_fn <- sub("_clone-pass.tsv$", "_command_log.txt", basename(output_fn))
}


# db <- data.frame(
#     'id'=c(1,2),
#     'subject_id'=c("A","A")
# )

output_files <- c()
output_sizes <- c()
if (sum(heavy_chains)>0 & nrow(db)>0) {
    
    output_groups <- db %>%
        ungroup() %>%
        select(!!!rlang::syms(params$outputby)) %>%
        distinct() 
    
    if (nrow(output_groups)>0) {
        for (i in 1:nrow(output_groups))  {
            group_db <- right_join(db,
                                   output_groups[i,,drop=F],
                                   by=params$outputby)
            
            group_db_label <- gsub("^id_","",makeLabel(group_db, fields= params$outputby))
            group_fn <- paste0(group_db_label,"_",output_fn)
            output_files <- c(output_files, group_fn)
            output_sizes <- c(output_sizes, nrow(group_db))
            write_rearrangement(group_db, file=group_fn)
        }
    } else {
        write_rearrangement(db, file=output_fn)
    }
}
```


```{r log}
cat("START>ClonePass", file=log_fn, append=F)
cat(paste0("\nFILE> ",basename(params$input)), file=log_fn, append=T)
if (length(output_files==1)) {
    cat(paste0("\nOUTPUT> ",basename(output_fn)), file=log_fn, append=T)
    cat(paste0("\nPASS> ",nrow(db)), file=log_fn, append=T)
} else {
    for (i in 1:length(output_files)) {
        cat(paste0("\nOUTPUT",i,"> ",output_files[i]), file=log_fn, append=T)
        cat(paste0("\nPASS",i,"> ",output_sizes[i]), file=log_fn, append=T)
    }
}
cat(paste0("\nPASS> ",sum(output_sizes)), file=log_fn, append=T)
cat(paste0("\nFAIL> ",input_size-sum(output_sizes)), file=log_fn, append=T)
```


```{r, child=c('versions.Rmd')}
```


