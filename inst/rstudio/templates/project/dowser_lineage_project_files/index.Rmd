--- 
title: "Immcantation - enchantR"
subtitle: "Dowser lineage"
author: ""
date: "Updated: `r date()`"
knit: "bookdown::render_book"
site: bookdown::bookdown_site
documentclass: book
bibliography: "references.bib"
biblio-style: apalike
link-citations: yes
description: "dowser build lineage trees"
output: enchantr::immcantation
params:
   input: 
      label: "`input`: Path to repertoires file"
      input: file
      value: "input.tsv"
   build:
       label: "`build`"
       input: text
       value: "igphyml"
   exec:
       label: "`exec`"
       input: text
       value: "/usr/local/share/igphyml/src/igphyml"
   minseq:
       label: "`minseq`"
       input: numeric
       value: 5
   traits:
       label: "`traits`"
       input: text
       value: "c_call"            
   tips:
       label: "`tips`"
       input: text
       value: "c_call"       
   outname:
      label: "`outname`"
      input: text
      value: "define-clones"
   nproc:
      label: "`nproc`"
      input: numeric
      value: 1
   log:
      label: "`log`"
      input: text
      value: "command_log"
   outdir:
      label: '`outdir`: Output directory'
      input: text
      value: !r file.path(getwd(),'enchantr')
   date: 
      label: '`date`: Run date'
      input: date
      value: !r format(Sys.time(), "%Y-%m-%d")
   logo:
      label: "`logo`: Path to report logo"
      input: file
      value: !r file.path("assets", "logo.png")
   logolink:
      label: "`logolink`: URL to be added to the logo"
      input: text
      value: "immcantation.org"
   echo: 
      label: '`echo`: Show code in the report.'
      input: checkbox
      value: TRUE
   cache:
      label: '`cache`: Use cached results'
      input: checkbox
      value: FALSE
editor_options: 
  chunk_output_type: console
---

```{r global-options, include=FALSE, cache=FALSE}
knitr::opts_chunk$set(fig.width=7, fig.height=4, fig.path = "figures/",
                      echo=params$echo,cache=params$cache,
                      warning=FALSE, message=FALSE,
                      eval.after="fig.cap",
                      out_dir=params$outdir,
                      eval.opts = c('eval', 'echo', 'fig.height', 'fig.width'))

# Libraries
suppressPackageStartupMessages(library("enchantr"))
suppressPackageStartupMessages(library("DT"))
suppressPackageStartupMessages(library("dplyr"))
suppressPackageStartupMessages(library("airr"))
suppressPackageStartupMessages(library("alakazam"))
suppressPackageStartupMessages(library("shazam"))
suppressPackageStartupMessages(library("scoper"))
suppressPackageStartupMessages(library("dowser"))
suppressPackageStartupMessages(library("igraph"))


if (!dir.exists(params[['outdir']])) {
    dir.create(params[['outdir']], recursive = T)
}

file.copy(params$logo, 
          file.path(params$outdir,"assets", "logo.png"),
          recursive = T, overwrite=T)
```

# Input parameters

```{r input-parameters, results='asis'}
printParams(params)
```
```{r echo=FALSE, results='asis'}
print_table_caption(tag="input", text="Input parameters.")
save(params, file=file.path(params$outdir,"params.RData"))
```

# Read repertoires


```{r}
# Read repertoire
db <- bind_rows(lapply(strsplit(params[['input']],",")[[1]], function(x) {
    # Check input file
    if (!file.exists(x)) {
        stop(paste0("File ", basename(x), " doesn't exist."))
    }
    read_rearrangement(x)}
))
input_size <- nrow(db)
```

# Formatting clones

```{r}
h <- isHeavyChain(db[['locus']]) #IGH, TRB, TRD
if (sum(h)>0) {
    heavy <- unique(db[['locus']][h])
    if (length(heavy)>1) {
        stop("multiple heavy chain locus found.")
    } 
    
    clones <- data.frame()
    
    traits <- params[['traits']]
    if (!is.null(traits)) {
        validTraits <- function(traits, db) {
            trait_exists <- sapply(traits, function(x) { 
                x %in% colnames(db)}
            )
            if (any(!trait_exists)) {
                message("Ignoring non-existing traits: ",paste(traits[!trait_exists], collapse = ", "))
                traits <- traits[trait_exists]
            }
            if (length(traits) == 0 ) { 
                traits <- NULL
                return (traits)
            }
            traits
        }
        traits <- validTraits(traits, db)
    }
    
    # Convert NA traits to "missing"
    miss <- function(x) {
        ifelse(is.na(x), "missing",x)
    }
    db <- db %>%
        mutate(across(all_of(c(traits)), miss)) 
    
    num_fields <- intersect(c("duplicate_count", "consensus_count"),colnames(db))
    if (length(num_fields) == 0 ) { num_fields <- NULL }
    
    try (
        clones <- formatClones(db,
                               traits=traits ,
                               num_fields=num_fields,
                               chain="H",
                               locus='locus',
                               heavy=heavy[[1]],
                               minseq=params$minseq, nproc=params$nproc) 
    )
    if (nrow(clones)>0) {
        trees <- getTrees(clones, 
                          build=params$build, 
                          exec=params$exec,
                          nproc=params$nproc)
        
        if ( params$tips %in% colnames(db) ) {
            tips <- params$tips
        } else {
            tips <- NULL
        }
        plots <- plotTrees(trees, tips=tips, tipsize=2)
        for (i in 1:length(plots)) {
            cat(paste0("## Tree ",i,"\n\n"))
            print(plots[[i]])
            cat("\n\n")
        }

        # Saving all trees in a PDF
        treesToPDF(plots, file.path(params$outdir, "all_trees.pdf"))

        # Converting trees to graphs
        graphs = lapply(trees$trees, phyloToGraph, germline="Germline")
        names(graphs) <- trees$clone_id

        # Saving all trees in graphML format
        lapply(names(graphs), function(x) igraph::write.graph(file = file.path(params$outdir, paste("clone_", x, ".graphml", sep="")), graph=graphs[[x]], format="graphml"))

    } else {
        cat("All clones have less than minseq = ",params$minseq," sequences.")
    }
    
}
```


# Versions

```{r, child=c('versions.Rmd')}
```


# Log

```{r log}

if (!is.null(params$log)) {
    log_fn <- paste0(params$log,".txt")
} else {
    log_fn <- sub("_clone-pass.tsv$", "_command_log.txt", basename(output_fn))
}


cat("START>DowserPass", file=log_fn, append=F)
cat(paste0("\nFILE> ",basename(params$input)), file=log_fn, append=T)
cat(paste0("\nOUTPUT> ",basename(params$input)), file=log_fn, append=T)
cat(paste0("\nPASS> ",nrow(db)), file=log_fn, append=T)
#cat(paste0("\nFAIL> ",input_size-sum(output_sizes)), file=log_fn, append=T)
```
